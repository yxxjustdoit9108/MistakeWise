import tkinter as tk
from tkinter import ttk, messagebox, filedialog
import sqlite3
import random
import os
import csv
from datetime import datetime

class MistakeWise:
    def __init__(self, root):
        self.root = root
        self.root.title("MistakeWise v2.0 - Smart Study Assistant")
        self.root.geometry("800x600")
        
        # È¢úËâ≤ÈÖçÁΩÆ
        self.colors = {
            'primary': '#2E86AB',
            'secondary': '#A23B72', 
            'success': '#27AE60',
            'warning': '#F39C12',
            'danger': '#E74C3C',
            'light_bg': '#F8F9FA',
            'dark_text': '#2C3E50'
        }
        
        # Initialize database with error handling
        try:
            self.init_database()
        except Exception as e:
            messagebox.showerror("Database Error", f"Failed to initialize database: {str(e)}")
            return
        
        # Create main interface
        self.create_interface()
        
        # Load initial data
        self.refresh_mistakes_list()
        self.refresh_topics_list()
        self.refresh_analytics()

    def init_database(self):
        """Initialize database and create tables with proper error handling"""
        conn = sqlite3.connect('mistakes.db')
        cursor = conn.cursor()
        
        try:
            # Main mistakes table
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS mistakes (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    question TEXT NOT NULL,
                    answer TEXT NOT NULL,
                    topic TEXT NOT NULL,
                    difficulty INTEGER DEFAULT 1,
                    times_reviewed INTEGER DEFAULT 0,
                    last_reviewed TIMESTAMP,
                    created_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            
            # Study sessions table
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS study_sessions (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    session_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    questions_reviewed INTEGER,
                    correct_answers INTEGER
                )
            ''')
            
            conn.commit()
            print("Database initialized successfully!")
            
        except Exception as e:
            conn.rollback()
            raise e
        finally:
            conn.close()

    def create_interface(self):
        """Create the main application interface"""
        
        # Create notebook (tabbed interface)
        self.notebook = ttk.Notebook(self.root)
        self.notebook.pack(fill='both', expand=True, padx=10, pady=10)
        
        # Tab 1: Add/Manage Mistakes
        self.create_management_tab()
        
        # Tab 2: Study Mode
        self.create_study_tab()
        
        # Tab 3: Analytics
        self.create_analytics_tab()

    def create_management_tab(self):
        """Create the mistake management tab"""
        management_frame = ttk.Frame(self.notebook)
        self.notebook.add(management_frame, text='Manage Mistakes')
        
        # Left panel - Input form
        left_frame = ttk.Frame(management_frame)
        left_frame.pack(side='left', fill='y', padx=(0, 10))
        
        # Input form
        input_frame = ttk.LabelFrame(left_frame, text='Add New Mistake', padding=10)
        input_frame.pack(fill='x', pady=(0, 10))
        
        # Topic selection/combo
        ttk.Label(input_frame, text='Topic:').grid(row=0, column=0, sticky='w', pady=5)
        self.topic_combo = ttk.Combobox(input_frame, width=25)
        self.topic_combo.grid(row=0, column=1, sticky='ew', pady=5, padx=(5, 0))
        
        # Question input
        ttk.Label(input_frame, text='Question:').grid(row=1, column=0, sticky='nw', pady=5)
        self.question_text = tk.Text(input_frame, width=30, height=4)
        self.question_text.grid(row=1, column=1, sticky='ew', pady=5, padx=(5, 0))
        
        # Answer input
        ttk.Label(input_frame, text='Answer:').grid(row=2, column=0, sticky='nw', pady=5)
        self.answer_text = tk.Text(input_frame, width=30, height=4)
        self.answer_text.grid(row=2, column=1, sticky='ew', pady=5, padx=(5, 0))
        
        # Difficulty
        ttk.Label(input_frame, text='Difficulty:').grid(row=3, column=0, sticky='w', pady=5)
        self.difficulty_var = tk.IntVar(value=1)
        difficulty_frame = ttk.Frame(input_frame)
        difficulty_frame.grid(row=3, column=1, sticky='w', pady=5, padx=(5, 0))
        for i in range(1, 6):
            ttk.Radiobutton(difficulty_frame, text=str(i), variable=self.difficulty_var, value=i).pack(side='left')
        
        # Buttons
        button_frame = ttk.Frame(input_frame)
        button_frame.grid(row=4, column=0, columnspan=2, pady=10)
        ttk.Button(button_frame, text='Save Mistake', command=self.save_mistake).pack(side='left', padx=5)
        ttk.Button(button_frame, text='Clear Form', command=self.clear_form).pack(side='left', padx=5)
        
        # Right panel - Mistakes list
        right_frame = ttk.Frame(management_frame)
        right_frame.pack(side='right', fill='both', expand=True)
        
        # Search frame
        search_frame = ttk.Frame(right_frame)
        search_frame.pack(fill='x', pady=(0, 10))
        
        ttk.Label(search_frame, text='Search:').pack(side='left')
        self.search_var = tk.StringVar()
        search_entry = ttk.Entry(search_frame, textvariable=self.search_var, width=30)
        search_entry.pack(side='left', padx=5)
        search_entry.bind('<KeyRelease>', self.search_mistakes)
        
        ttk.Label(search_frame, text='Filter by Topic:').pack(side='left', padx=(20, 5))
        self.filter_var = tk.StringVar(value='All Topics')
        self.filter_combo = ttk.Combobox(search_frame, textvariable=self.filter_var, width=15)
        self.filter_combo.pack(side='left', padx=5)
        self.filter_combo.bind('<<ComboboxSelected>>', self.filter_mistakes)
        
        # Listbox with scrollbar
        list_frame = ttk.Frame(right_frame)
        list_frame.pack(fill='both', expand=True)
        
        # Create treeview for better display
        columns = ('ID', 'Topic', 'Question', 'Difficulty', 'Last Reviewed')
        self.mistakes_tree = ttk.Treeview(list_frame, columns=columns, show='headings', height=15)
        
        # Define headings
        self.mistakes_tree.heading('ID', text='ID')
        self.mistakes_tree.heading('Topic', text='Topic')
        self.mistakes_tree.heading('Question', text='Question')
        self.mistakes_tree.heading('Difficulty', text='Difficulty')
        self.mistakes_tree.heading('Last Reviewed', text='Last Reviewed')
        
        # Set column widths
        self.mistakes_tree.column('ID', width=40)
        self.mistakes_tree.column('Topic', width=100)
        self.mistakes_tree.column('Question', width=300)
        self.mistakes_tree.column('Difficulty', width=80)
        self.mistakes_tree.column('Last Reviewed', width=120)
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(list_frame, orient='vertical', command=self.mistakes_tree.yview)
        self.mistakes_tree.configure(yscrollcommand=scrollbar.set)
        
        self.mistakes_tree.pack(side='left', fill='both', expand=True)
        scrollbar.pack(side='right', fill='y')
        
        # Bind double-click to edit
        self.mistakes_tree.bind('<Double-1>', self.edit_mistake)
        
        # Action buttons for list
        action_frame = ttk.Frame(right_frame)
        action_frame.pack(fill='x', pady=10)
        ttk.Button(action_frame, text='Edit Selected', command=self.edit_mistake).pack(side='left', padx=5)
        ttk.Button(action_frame, text='Delete Selected', command=self.delete_mistake).pack(side='left', padx=5)
        ttk.Button(action_frame, text='Refresh', command=self.refresh_mistakes_list).pack(side='left', padx=5)
        
        # Êñ∞Â¢ûÔºöÂØºÂÖ•ÂØºÂá∫ÊåâÈíÆ
        ttk.Button(action_frame, text='Export CSV', command=self.export_to_csv).pack(side='left', padx=5)
        ttk.Button(action_frame, text='Import CSV', command=self.import_from_csv).pack(side='left', padx=5)
        ttk.Button(action_frame, text='Export Report', command=self.export_statistics_report).pack(side='left', padx=5)

    def create_study_tab(self):
        """Create the study/practice tab"""
        study_frame = ttk.Frame(self.notebook)
        self.notebook.add(study_frame, text='Study Mode')
        
        # Configuration frame
        config_frame = ttk.LabelFrame(study_frame, text='Study Settings', padding=10)
        config_frame.pack(fill='x', pady=(0, 10))
        
        # Topic selection for study
        ttk.Label(config_frame, text='Study Topic:').grid(row=0, column=0, sticky='w', pady=5)
        self.study_topic_var = tk.StringVar(value='All Topics')
        self.study_topic_combo = ttk.Combobox(config_frame, textvariable=self.study_topic_var, width=20)
        self.study_topic_combo.grid(row=0, column=1, sticky='w', pady=5, padx=5)
        
        # Difficulty filter
        ttk.Label(config_frame, text='Max Difficulty:').grid(row=0, column=2, sticky='w', pady=5, padx=(20, 0))
        self.study_difficulty_var = tk.IntVar(value=5)
        study_diff_combo = ttk.Combobox(config_frame, textvariable=self.study_difficulty_var, 
                                      values=[1, 2, 3, 4, 5], width=5)
        study_diff_combo.grid(row=0, column=3, sticky='w', pady=5, padx=5)
        
        # Number of questions
        ttk.Label(config_frame, text='Questions:').grid(row=1, column=0, sticky='w', pady=5)
        self.question_count_var = tk.IntVar(value=5)
        question_spinbox = ttk.Spinbox(config_frame, from_=1, to=50, textvariable=self.question_count_var, width=5)
        question_spinbox.grid(row=1, column=1, sticky='w', pady=5, padx=5)
        
        # Start study session button
        ttk.Button(config_frame, text='Start Study Session', command=self.start_study_session).grid(row=1, column=2, columnspan=2, pady=5, padx=20)
        
        # Study area
        self.study_area_frame = ttk.LabelFrame(study_frame, text='Current Question', padding=20)
        
        # Progress label
        self.progress_label = ttk.Label(self.study_area_frame, text='', font=('Arial', 10))
        self.progress_label.pack(anchor='w', pady=(0, 10))
        
        # Question display
        question_title = ttk.Label(self.study_area_frame, text='Question:', font=('Arial', 12, 'bold'))
        question_title.pack(anchor='w')
        
        self.question_display = tk.Text(self.study_area_frame, height=6, width=70, wrap='word')
        self.question_display.pack(fill='x', pady=10)
        self.question_display.config(state='disabled')
        
        # Show answer button and answer display
        self.show_answer_btn = ttk.Button(self.study_area_frame, text='Show Answer', command=self.show_answer)
        self.show_answer_btn.pack(pady=10)
        
        self.answer_display = tk.Text(self.study_area_frame, height=6, width=70, wrap='word')
        self.answer_display.config(state='disabled')
        
        # Difficulty rating and navigation
        nav_frame = ttk.Frame(self.study_area_frame)
        nav_frame.pack(fill='x', pady=20)
        
        ttk.Label(nav_frame, text='How well did you know this?').pack(side='left')
        
        self.rating_var = tk.IntVar(value=3)
        for i in range(1, 6):
            ttk.Radiobutton(nav_frame, text=str(i), variable=self.rating_var, value=i).pack(side='left', padx=5)
        
        ttk.Button(nav_frame, text='Next Question', command=self.next_study_question).pack(side='right', padx=5)
        ttk.Button(nav_frame, text='End Session', command=self.end_study_session).pack(side='right', padx=5)

        # Results frame
        self.results_frame = ttk.LabelFrame(study_frame, text='Session Results', padding=10)

    def create_analytics_tab(self):
        """Create the analytics tab"""
        analytics_frame = ttk.Frame(self.notebook)
        self.notebook.add(analytics_frame, text='Analytics')
        
        # Stats frame
        stats_frame = ttk.LabelFrame(analytics_frame, text='Overall Statistics', padding=15)
        stats_frame.pack(fill='x', pady=10)
        
        # Create stats labels
        self.total_mistakes_label = ttk.Label(stats_frame, text='Total Mistakes: 0', font=('Arial', 10))
        self.total_mistakes_label.grid(row=0, column=0, sticky='w', pady=5)
        
        self.total_topics_label = ttk.Label(stats_frame, text='Total Topics: 0', font=('Arial', 10))
        self.total_topics_label.grid(row=0, column=1, sticky='w', pady=5, padx=20)
        
        self.avg_difficulty_label = ttk.Label(stats_frame, text='Average Difficulty: 0.0', font=('Arial', 10))
        self.avg_difficulty_label.grid(row=1, column=0, sticky='w', pady=5)
        
        # Êñ∞Â¢ûÔºöÂØºÂá∫Êä•ÂëäÊåâÈíÆ
        ttk.Button(stats_frame, text='Export Full Report', command=self.export_statistics_report).grid(row=1, column=1, sticky='w', pady=5, padx=20)
        
        # Topics breakdown frame
        topics_frame = ttk.LabelFrame(analytics_frame, text='Mistakes by Topic', padding=15)
        topics_frame.pack(fill='both', expand=True, pady=10)
        
        # Treeview for topics breakdown
        columns = ('Topic', 'Count', 'Avg Difficulty')
        self.topics_tree = ttk.Treeview(topics_frame, columns=columns, show='headings', height=10)
        
        self.topics_tree.heading('Topic', text='Topic')
        self.topics_tree.heading('Count', text='Mistake Count')
        self.topics_tree.heading('Avg Difficulty', text='Avg Difficulty')
        
        self.topics_tree.column('Topic', width=200)
        self.topics_tree.column('Count', width=100)
        self.topics_tree.column('Avg Difficulty', width=100)
        
        scrollbar = ttk.Scrollbar(topics_frame, orient='vertical', command=self.topics_tree.yview)
        self.topics_tree.configure(yscrollcommand=scrollbar.set)
        
        self.topics_tree.pack(side='left', fill='both', expand=True)
        scrollbar.pack(side='right', fill='y')
        
        # Refresh analytics button
        ttk.Button(analytics_frame, text='Refresh Analytics', command=self.refresh_analytics).pack(pady=10)

    # Êñ∞Â¢ûÔºöÊï∞ÊçÆÂØºÂÖ•ÂØºÂá∫ÂäüËÉΩ
    def export_to_csv(self):
        """Export all mistakes to CSV file"""
        try:
            # Connect to database
            conn = sqlite3.connect('mistakes.db')
            cursor = conn.cursor()
            cursor.execute('''
                SELECT topic, question, answer, difficulty, times_reviewed, 
                       last_reviewed, created_date 
                FROM mistakes
            ''')
            mistakes = cursor.fetchall()
            conn.close()
            
            if not mistakes:
                messagebox.showinfo('Info', 'No data to export!')
                return
            
            # Generate filename with timestamp
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"mistakes_export_{timestamp}.csv"
            
            # Write to CSV file
            with open(filename, 'w', newline='', encoding='utf-8') as csvfile:
                writer = csv.writer(csvfile)
                
                # Write header
                writer.writerow([
                    'Topic', 'Question', 'Answer', 'Difficulty', 
                    'Times Reviewed', 'Last Reviewed', 'Created Date'
                ])
                
                # Write data
                for mistake in mistakes:
                    writer.writerow(mistake)
            
            messagebox.showinfo('Export Success', f'Data exported to: {filename}')
            
        except Exception as e:
            messagebox.showerror('Export Error', f'Export failed: {str(e)}')

    def import_from_csv(self):
        """Import mistakes from CSV file"""
        try:
            # Open file dialog
            filepath = filedialog.askopenfilename(
                title='Select CSV File',
                filetypes=[('CSV files', '*.csv'), ('All files', '*.*')]
            )
            
            if not filepath:
                return  # User canceled
            
            # Read CSV file
            imported_count = 0
            with open(filepath, 'r', encoding='utf-8') as csvfile:
                reader = csv.reader(csvfile)
                
                # Skip header
                header = next(reader, None)
                
                # Connect to database
                conn = sqlite3.connect('mistakes.db')
                cursor = conn.cursor()
                
                for row in reader:
                    if len(row) >= 4:  # At least topic, question, answer, difficulty
                        topic, question, answer, difficulty = row[0], row[1], row[2], row[3]
                        
                        # Validate and set default values
                        if not difficulty.isdigit() or not (1 <= int(difficulty) <= 5):
                            difficulty = 1
                        
                        # Insert into database
                        cursor.execute('''
                            INSERT OR IGNORE INTO mistakes 
                            (topic, question, answer, difficulty) 
                            VALUES (?, ?, ?, ?)
                        ''', (topic, question, answer, int(difficulty)))
                        
                        imported_count += 1
                
                conn.commit()
                conn.close()
            
            messagebox.showinfo('Import Success', f'Successfully imported {imported_count} mistakes!')
            
            # Refresh displays
            self.refresh_mistakes_list()
            self.refresh_topics_list()
            self.refresh_analytics()
            
        except Exception as e:
            messagebox.showerror('Import Error', f'Import failed: {str(e)}')

    def export_statistics_report(self):
        """Export learning statistics report"""
        try:
            conn = sqlite3.connect('mistakes.db')
            cursor = conn.cursor()
            
            # Get statistics
            cursor.execute('SELECT COUNT(*) FROM mistakes')
            total_mistakes = cursor.fetchone()[0]
            
            cursor.execute('SELECT COUNT(DISTINCT topic) FROM mistakes')
            total_topics = cursor.fetchone()[0]
            
            cursor.execute('SELECT AVG(difficulty) FROM mistakes')
            avg_difficulty = cursor.fetchone()[0] or 0
            
            cursor.execute('SELECT SUM(times_reviewed) FROM mistakes')
            total_reviews = cursor.fetchone()[0] or 0
            
            cursor.execute('SELECT COUNT(*) FROM study_sessions')
            total_sessions = cursor.fetchone()[0] or 0
            
            # Get topic breakdown
            cursor.execute('''
                SELECT topic, COUNT(*), AVG(difficulty) 
                FROM mistakes 
                GROUP BY topic 
                ORDER BY COUNT(*) DESC
            ''')
            topics_breakdown = cursor.fetchall()
            
            # Generate report file
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"learning_report_{timestamp}.txt"
            
            with open(filename, 'w', encoding='utf-8') as f:
                f.write("=== MISTAKEWISE LEARNING REPORT ===\n")
                f.write(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                f.write("=" * 40 + "\n\n")
                
                f.write("OVERALL STATISTICS:\n")
                f.write(f"  Total Mistakes: {total_mistakes}\n")
                f.write(f"  Total Topics: {total_topics}\n")
                f.write(f"  Average Difficulty: {avg_difficulty:.1f}/5.0\n")
                f.write(f"  Total Reviews: {total_reviews}\n")
                f.write(f"  Study Sessions: {total_sessions}\n\n")
                
                f.write("TOPICS BREAKDOWN:\n")
                for topic, count, avg_diff in topics_breakdown:
                    f.write(f"  {topic}: {count} mistakes (avg difficulty: {avg_diff:.1f}/5.0)\n")
                
                f.write("\n" + "=" * 40 + "\n")
                f.write("Keep up the great work! Learning is a journey. üí™\n")
            
            messagebox.showinfo('Report Generated', f'Learning report exported to: {filename}')
            
            conn.close()
            
        except Exception as e:
            messagebox.showerror('Error', f'Failed to generate report: {str(e)}')

    # Database operations
    def get_all_topics(self):
        """Get all unique topics from database"""
        conn = sqlite3.connect('mistakes.db')
        cursor = conn.cursor()
        cursor.execute('SELECT DISTINCT topic FROM mistakes ORDER BY topic')
        topics = [row[0] for row in cursor.fetchall()]
        conn.close()
        return topics

    def refresh_topics_list(self):
        """Refresh topics in all combo boxes"""
        topics = self.get_all_topics()
        self.topic_combo['values'] = topics
        self.filter_combo['values'] = ['All Topics'] + topics
        self.study_topic_combo['values'] = ['All Topics'] + topics

    def save_mistake(self):
        """Save a new mistake to database"""
        topic = self.topic_combo.get().strip()
        question = self.question_text.get('1.0', 'end-1c').strip()
        answer = self.answer_text.get('1.0', 'end-1c').strip()
        difficulty = self.difficulty_var.get()
        
        if not topic or not question or not answer:
            messagebox.showerror('Error', 'Please fill in all fields!')
            return
        
        try:
            conn = sqlite3.connect('mistakes.db')
            cursor = conn.cursor()
            
            cursor.execute('''
                INSERT INTO mistakes (question, answer, topic, difficulty)
                VALUES (?, ?, ?, ?)
            ''', (question, answer, topic, difficulty))
            
            conn.commit()
            conn.close()
            
            messagebox.showinfo('Success', 'Mistake saved successfully!')
            self.clear_form()
            self.refresh_mistakes_list()
            self.refresh_topics_list()
            self.refresh_analytics()
        except Exception as e:
            messagebox.showerror('Database Error', f'Failed to save mistake: {str(e)}')

    def clear_form(self):
        """Clear the input form"""
        self.question_text.delete('1.0', 'end')
        self.answer_text.delete('1.0', 'end')
        self.difficulty_var.set(1)

    def refresh_mistakes_list(self, search_term='', topic_filter='All Topics'):
        """Refresh the mistakes list with optional filtering"""
        # Clear current list
        for item in self.mistakes_tree.get_children():
            self.mistakes_tree.delete(item)
        
        try:
            conn = sqlite3.connect('mistakes.db')
            cursor = conn.cursor()
            
            # Build query with filters
            query = 'SELECT id, topic, question, difficulty, last_reviewed FROM mistakes WHERE 1=1'
            params = []
            
            if search_term:
                query += ' AND (question LIKE ? OR topic LIKE ?)'
                params.extend([f'%{search_term}%', f'%{search_term}%'])
            
            if topic_filter != 'All Topics':
                query += ' AND topic = ?'
                params.append(topic_filter)
            
            query += ' ORDER BY created_date DESC'
            
            cursor.execute(query, params)
            mistakes = cursor.fetchall()
            
            for mistake in mistakes:
                last_reviewed = mistake[4] or 'Never'
                question_text = mistake[2]
                if len(question_text) > 100:
                    question_text = question_text[:100] + '...'
                
                self.mistakes_tree.insert('', 'end', values=(
                    mistake[0], mistake[1], question_text, mistake[3], last_reviewed
                ))
            
            conn.close()
        except Exception as e:
            messagebox.showerror('Database Error', f'Failed to load mistakes: {str(e)}')

    def search_mistakes(self, event=None):
        """Search mistakes based on search term"""
        search_term = self.search_var.get()
        topic_filter = self.filter_var.get()
        self.refresh_mistakes_list(search_term, topic_filter)

    def filter_mistakes(self, event=None):
        """Filter mistakes by topic"""
        search_term = self.search_var.get()
        topic_filter = self.filter_var.get()
        self.refresh_mistakes_list(search_term, topic_filter)

    def edit_mistake(self, event=None):
        """Edit selected mistake"""
        selection = self.mistakes_tree.selection()
        if not selection:
            messagebox.showwarning('Warning', 'Please select a mistake to edit!')
            return
        
        item = self.mistakes_tree.item(selection[0])
        mistake_id = item['values'][0]
        
        # Fetch full mistake details
        try:
            conn = sqlite3.connect('mistakes.db')
            cursor = conn.cursor()
            cursor.execute('SELECT question, answer, topic, difficulty FROM mistakes WHERE id = ?', (mistake_id,))
            mistake = cursor.fetchone()
            conn.close()
            
            if mistake:
                # Create edit window
                self.create_edit_window(mistake_id, mistake)
        except Exception as e:
            messagebox.showerror('Database Error', f'Failed to load mistake: {str(e)}')

    def create_edit_window(self, mistake_id, mistake):
        """Create window for editing mistakes"""
        edit_window = tk.Toplevel(self.root)
        edit_window.title('Edit Mistake')
        edit_window.geometry('500x400')
        edit_window.grab_set()  # Make window modal
        
        ttk.Label(edit_window, text='Edit Mistake', font=('Arial', 14, 'bold')).pack(pady=10)
        
        # Topic
        ttk.Label(edit_window, text='Topic:').pack(anchor='w', padx=20, pady=(10, 5))
        topic_var = tk.StringVar(value=mistake[2])
        topic_entry = ttk.Entry(edit_window, textvariable=topic_var, width=50)
        topic_entry.pack(fill='x', padx=20, pady=5)
        
        # Question
        ttk.Label(edit_window, text='Question:').pack(anchor='w', padx=20, pady=(10, 5))
        question_text = tk.Text(edit_window, height=6, width=50)
        question_text.pack(fill='x', padx=20, pady=5)
        question_text.insert('1.0', mistake[0])
        
        # Answer
        ttk.Label(edit_window, text='Answer:').pack(anchor='w', padx=20, pady=(10, 5))
        answer_text = tk.Text(edit_window, height=6, width=50)
        answer_text.pack(fill='x', padx=20, pady=5)
        answer_text.insert('1.0', mistake[1])
        
        # Difficulty
        ttk.Label(edit_window, text='Difficulty:').pack(anchor='w', padx=20, pady=(10, 5))
        difficulty_var = tk.IntVar(value=mistake[3])
        diff_frame = ttk.Frame(edit_window)
        diff_frame.pack(fill='x', padx=20, pady=5)
        for i in range(1, 6):
            ttk.Radiobutton(diff_frame, text=str(i), variable=difficulty_var, value=i).pack(side='left')
        
        # Buttons
        button_frame = ttk.Frame(edit_window)
        button_frame.pack(fill='x', pady=20)
        
        def save_edits():
            new_topic = topic_var.get().strip()
            new_question = question_text.get('1.0', 'end-1c').strip()
            new_answer = answer_text.get('1.0', 'end-1c').strip()
            new_difficulty = difficulty_var.get()
            
            if not new_topic or not new_question or not new_answer:
                messagebox.showerror('Error', 'Please fill in all fields!')
                return
            
            try:
                conn = sqlite3.connect('mistakes.db')
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE mistakes 
                    SET topic=?, question=?, answer=?, difficulty=?
                    WHERE id=?
                ''', (new_topic, new_question, new_answer, new_difficulty, mistake_id))
                conn.commit()
                conn.close()
                
                messagebox.showinfo('Success', 'Mistake updated successfully!')
                edit_window.destroy()
                self.refresh_mistakes_list()
                self.refresh_topics_list()
                self.refresh_analytics()
            except Exception as e:
                messagebox.showerror('Database Error', f'Failed to update mistake: {str(e)}')
        
        ttk.Button(button_frame, text='Save Changes', command=save_edits).pack(side='left', padx=10)
        ttk.Button(button_frame, text='Cancel', command=edit_window.destroy).pack(side='left', padx=10)

    def delete_mistake(self):
        """Delete selected mistake"""
        selection = self.mistakes_tree.selection()
        if not selection:
            messagebox.showwarning('Warning', 'Please select a mistake to delete!')
            return
        
        if messagebox.askyesno('Confirm Delete', 'Are you sure you want to delete this mistake?'):
            item = self.mistakes_tree.item(selection[0])
            mistake_id = item['values'][0]
            
            try:
                conn = sqlite3.connect('mistakes.db')
                cursor = conn.cursor()
                cursor.execute('DELETE FROM mistakes WHERE id = ?', (mistake_id,))
                conn.commit()
                conn.close()
                
                messagebox.showinfo('Success', 'Mistake deleted successfully!')
                self.refresh_mistakes_list()
                self.refresh_topics_list()
                self.refresh_analytics()
            except Exception as e:
                messagebox.showerror('Database Error', f'Failed to delete mistake: {str(e)}')

    # Study session functionality
    def start_study_session(self):
        """Start a new study session"""
        topic = self.study_topic_var.get()
        max_difficulty = self.study_difficulty_var.get()
        question_count = self.question_count_var.get()
        
        # Get questions for study session
        try:
            conn = sqlite3.connect('mistakes.db')
            cursor = conn.cursor()
            
            query = 'SELECT id, question, answer, topic, difficulty FROM mistakes WHERE difficulty <= ?'
            params = [max_difficulty]
            
            if topic != 'All Topics':
                query += ' AND topic = ?'
                params.append(topic)
            
            query += ' ORDER BY last_reviewed ASC, times_reviewed ASC, RANDOM() LIMIT ?'
            params.append(question_count)
            
            cursor.execute(query, params)
            self.study_questions = cursor.fetchall()
            conn.close()
            
            if not self.study_questions:
                messagebox.showwarning('Warning', 'No questions match your criteria!')
                return
            
            # Initialize study session
            self.current_question_index = 0
            self.correct_answers = 0
            self.answered_questions = 0
            
            # Hide config, show study area
            self.study_area_frame.pack(fill='both', expand=True, padx=10, pady=10)
            self.results_frame.pack_forget()
            
            # Show first question
            self.show_study_question()
        except Exception as e:
            messagebox.showerror('Database Error', f'Failed to start study session: {str(e)}')

    def show_study_question(self):
        """Display current study question"""
        if self.current_question_index >= len(self.study_questions):
            self.end_study_session()
            return
        
        # Reset UI state
        self.answer_display.pack_forget()
        self.show_answer_btn.pack(pady=10)
        
        # Get current question
        question_data = self.study_questions[self.current_question_index]
        self.current_question_id = question_data[0]
        
        # Update progress
        self.progress_label.config(
            text=f'Question {self.current_question_index + 1} of {len(self.study_questions)} | '
                 f'Topic: {question_data[3]} | Difficulty: {question_data[4]}'
        )
        
        # Display question
        self.question_display.config(state='normal')
        self.question_display.delete('1.0', 'end')
        self.question_display.insert('1.0', question_data[1])
        self.question_display.config(state='disabled')
        
        # Store answer for later
        self.current_answer = question_data[2]

    def show_answer(self):
        """Show answer for current question"""
        self.show_answer_btn.pack_forget()
        
        # Display answer
        self.answer_display.config(state='normal')
        self.answer_display.delete('1.0', 'end')
        self.answer_display.insert('1.0', self.current_answer)
        self.answer_display.config(state='disabled')
        self.answer_display.pack(fill='x', pady=10)

    def next_study_question(self):
        """Move to next question in study session"""
        # Update question stats in database
        rating = self.rating_var.get()
        try:
            conn = sqlite3.connect('mistakes.db')
            cursor = conn.cursor()
            cursor.execute('''
                UPDATE mistakes 
                SET times_reviewed = times_reviewed + 1, 
                    last_reviewed = CURRENT_TIMESTAMP
                WHERE id = ?
            ''', (self.current_question_id,))
            conn.commit()
            conn.close()
            
            # Track performance
            self.answered_questions += 1
            if rating >= 4:  # Consider ratings 4-5 as "known well"
                self.correct_answers += 1
            
            # Move to next question
            self.current_question_index += 1
            self.show_study_question()
        except Exception as e:
            messagebox.showerror('Database Error', f'Failed to update question: {str(e)}')

    def end_study_session(self):
        """End current study session and show results"""
        # Hide study area, show results
        self.study_area_frame.pack_forget()
        
        # Clear results frame
        for widget in self.results_frame.winfo_children():
            widget.destroy()
        
        # Calculate results
        accuracy = (self.correct_answers / self.answered_questions * 100) if self.answered_questions > 0 else 0
        
        # Display results
        ttk.Label(self.results_frame, text='Study Session Completed!', 
                 font=('Arial', 14, 'bold')).pack(pady=10)
        
        ttk.Label(self.results_frame, 
                 text=f'Questions Answered: {self.answered_questions}').pack(pady=5)
        ttk.Label(self.results_frame, 
                 text=f'Correct Answers: {self.correct_answers}').pack(pady=5)
        ttk.Label(self.results_frame, 
                 text=f'Accuracy: {accuracy:.1f}%').pack(pady=5)
        
        ttk.Button(self.results_frame, text='Start New Session', 
                  command=self.start_new_session).pack(pady=10)
        
        self.results_frame.pack(fill='both', expand=True, padx=10, pady=10)
        
        # Save session to database
        try:
            conn = sqlite3.connect('mistakes.db')
            cursor = conn.cursor()
            cursor.execute('''
                INSERT INTO study_sessions (questions_reviewed, correct_answers)
                VALUES (?, ?)
            ''', (self.answered_questions, self.correct_answers))
            conn.commit()
            conn.close()
        except Exception as e:
            print(f"Failed to save session: {str(e)}")

    def start_new_session(self):
        """Return to study configuration"""
        self.results_frame.pack_forget()
        self.study_area_frame.pack_forget()

    # Analytics functionality
    def refresh_analytics(self):
        """Refresh analytics data"""
        try:
            conn = sqlite3.connect('mistakes.db')
            cursor = conn.cursor()
            
            # Total mistakes
            cursor.execute('SELECT COUNT(*) FROM mistakes')
            total_mistakes = cursor.fetchone()[0]
            
            # Total topics
            cursor.execute('SELECT COUNT(DISTINCT topic) FROM mistakes')
            total_topics = cursor.fetchone()[0]
            
            # Average difficulty
            cursor.execute('SELECT AVG(difficulty) FROM mistakes')
            avg_difficulty = cursor.fetchone()[0] or 0
            
            # Update labels
            self.total_mistakes_label.config(text=f'Total Mistakes: {total_mistakes}')
            self.total_topics_label.config(text=f'Total Topics: {total_topics}')
            self.avg_difficulty_label.config(text=f'Average Difficulty: {avg_difficulty:.1f}')
            
            # Topics breakdown
            for item in self.topics_tree.get_children():
                self.topics_tree.delete(item)
            
            cursor.execute('''
                SELECT topic, COUNT(*), AVG(difficulty) 
                FROM mistakes 
                GROUP BY topic 
                ORDER BY COUNT(*) DESC
            ''')
            
            for topic, count, avg_diff in cursor.fetchall():
                self.topics_tree.insert('', 'end', values=(
                    topic, count, f'{avg_diff:.1f}' if avg_diff else '0.0'
                ))
            
            conn.close()
        except Exception as e:
            messagebox.showerror('Database Error', f'Failed to load analytics: {str(e)}')

def main():
    root = tk.Tk()
    app = MistakeWise(root)
    root.mainloop()

if __name__ == '__main__':
    main()
